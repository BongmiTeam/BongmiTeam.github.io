<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ART和JVM的区别</title>
      <link href="/2022/11/01/ART%E5%92%8CJVM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/01/ART%E5%92%8CJVM%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="ART基于寄存器，JVM基于栈"><a href="#ART基于寄存器，JVM基于栈" class="headerlink" title="ART基于寄存器，JVM基于栈"></a>ART基于寄存器，JVM基于栈</h2><p><img src="/images/17942410-af93837f33467394.webp"></p><p>堆区： 只存放类对象，实例化的数据放在堆区；堆区的数据放在主内存<br>方法区：又叫静态存储区，存放class文件和静态数据，全局变量;方法区的数据在主内存<br>栈区：存放方法局部变量，方法，线程不共享; 栈区的数据在高速缓冲区  </p><h3 id="主内存-高速缓冲区"><a href="#主内存-高速缓冲区" class="headerlink" title="主内存 高速缓冲区"></a>主内存 高速缓冲区</h3><p><img src="/images/17942410-d399ec19059fb3ed.webp"></p><p>堆区和方法区在内存条上<br>栈区在cpu的高速缓冲区上<br>因为cpu的读取速度在2.4G左右，内存条的速度1333M、1666M，两者之间有差异所以需要一个高速缓冲区（三级缓存）<br><img src="/images/20221101-160505.png"></p><h3 id="ART基于寄存器"><a href="#ART基于寄存器" class="headerlink" title="ART基于寄存器"></a>ART基于寄存器</h3><pre><code>public  Singleton getInstance() &#123;    Singleton instance = new Singleton();    return instance;&#125;</code></pre><p>翻译成arm指令</p><pre><code>0000: new-instance v0, Singleton // type@00000002: invoke-direct &#123;v0&#125;, Singleton.&lt;init&gt;:()V // method@00000005: return-object v0</code></pre><h3 id="JVM基于栈"><a href="#JVM基于栈" class="headerlink" title="JVM基于栈"></a>JVM基于栈</h3><p>IDEA字节码<br><img src="/images/20221101-160830.png"></p><p>栈结构<br><img src="/images/407483503-61b2ca47c0c01_fix732.png"></p><h2 id="ART执行效率高"><a href="#ART执行效率高" class="headerlink" title="ART执行效率高"></a>ART执行效率高</h2><h3 id="更快的本机方法"><a href="#更快的本机方法" class="headerlink" title="更快的本机方法"></a>更快的本机方法</h3><p>使用 <strong>@FastNative</strong> 和 <strong>@CriticalNative</strong> 注解可以更快地调用Java Native Interface (JNI)。这些内置的 ART 运行时优化可加快 JNI 转换并替换现在已弃用的!bang JNI表示法。注释对非本机方法没有影响，并且仅可用于引导类bootclasspath上的平台 Java 语言代码（无 Play 商店更新）。</p><p>@FastNative注解支持非静态方法。如果方法将jobject作为参数或返回值访问，请使用此选项。</p><p>@CriticalNative注解提供了一种更快的方式来运行本机方法，但有以下限制：  </p><pre><code>方法必须是静态的——没有参数、返回值或隐式this的对象。只有原始类型被传递给本机方法。本机方法在其函数定义中不使用JNIEnv和jclass参数。该方法必须使用RegisterNatives ，而不是依赖动态 JNI 链接。@FastNative和@CriticalNative注释在执行本机方法时禁用垃圾收集。不要与长时间运行的方法一起使用，包括通常快速但通常不受限制的方法。</code></pre><p>垃圾收集暂停可能会导致死锁。如果锁定尚未在本地释放（即在返回托管代码之前），则不要在快速本机调用期间获取锁定。这不适用于常规 JNI 调用，因为 ART 将执行的本机代码视为已挂起。</p><p>@FastNative可以将本机方法性能提高多达 3 倍， @CriticalNative CriticalNative 可以提高多达 5 倍。</p><pre><code>class ArtMethod   &#123;    // The hotness we measure for this method. Managed by the interpreter. Not atomic, as we allow    // 通过注释可以知道  该变量时标记经过 java方法运行的频率，    uint16_t hotness_count_;    struct PtrSizedFields &#123;    // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.    //通过google给我们的注释 可以知道，缓存一个方法对应的arm指令，快速的得到结果    ArtMethod** dex_cache_resolved_methods_;    //上面方法执行的结果 数据缓存在data_ 变量中，下次执行经过@FastNative修饰的java方法时，直接取出数据    void* data_;    //arm指令在内存中的地址，快速的定位到arm指令    void* entry_point_from_quick_compiled_code_;&#125; ptr_sized_fields_;  </code></pre><h3 id="dex优化"><a href="#dex优化" class="headerlink" title="dex优化"></a>dex优化</h3><p>dex文件结构<br><img src="/images/out4fhht2b.png"></p><h4 id="odex"><a href="#odex" class="headerlink" title="odex"></a>odex</h4><p>因为 apk 实际为 zip 压缩包，虚拟机每次加载都需要从 apk 中读取classes.dex 文件，这样会耗费很多的时间，而如果采用了 odex 方式优化的 dex 文件，他包含了加载 dex 必须的依赖库文件列表，只需要直接加载而不需要再去解析。</p><p>在 Android N 之前，对于在 dalvik 环境中 使用 dexopt 来对 dex 字节码进行优化生成 odex 文件最终存在手机的 data/dalvik-cache 目录下，最后把 apk 文件中的 dex 文件删除。</p><p>在 Android O 之后，odex 是从 vdex 这个文件中 提取了部分模块生成的一个新的可执行二进制码文件 ， odex 从 vdex 中提取后，vdex 的大小就减少了。</p><p>第一次开机就会生成在 /system/app/&lt;packagename&gt;/oat/ 下<br>在系统运行过程中，虚拟机将其 从 /system/app 下 copy 到 /data/davilk-cache/ 下;<br>odex + vdex = apk 的全部源码 （vdex 并不是独立于 odex 的文件 odex + vdex 才代表一个 apk </p><h4 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h4><p>ART 推出了预先 (AOT) 编译，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。该实用工具接受 DEX 文件作为输入，并针对目标设备生成已编译应用的可执行文件。之后打开 App 的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。</p><p>AOT 是 art 的核心，oat 文件包含 oatdata 和 oatexec。前者包含 dex 文件内容，后者包含生成的本地机器指令，从这里看出 oat 文件回会比 dex 文件占用更大的存储空间。</p><p>因为 oat 文件包含生成的本地机器指令进而可以直接运行，它同样保存在手机的 data/dalvik-cache 目录下 PMS(PackgetManagerService)—&gt;installd(守护进程)——&gt;dex2oat(/system/bin/dex2oat) 。注意存放在 data/dalvik-cache 目录下的后缀名都仍为 .dex 前者其实表示一个优化过的 .dex 文件 后者为 .art 文件。</p><p>push 一个新的 apk 文件覆盖之前 /system/app 下 apk 文件，会触发 PKMS 扫描时下发 force_dex flag ，强行生成新的 vdex文件 ，覆盖之前的vdex 文件，由于某种机制，这个新 vdex 文件会 copy 到 /data/dalvik-cache/ 下，于是 art 文件也变化了。</p><h2 id="引用文档"><a href="#引用文档" class="headerlink" title="引用文档"></a>引用文档</h2><p>Android系统8.0为什么比7.0要快50%，深入虚拟机源码发现答案 <a href="https://www.jianshu.com/p/41373fc26fd1">https://www.jianshu.com/p/41373fc26fd1</a><br>art改进 <a href="https://source.android.com/docs/core/runtime/improvements?hl=zh-cn">https://source.android.com/docs/core/runtime/improvements?hl=zh-cn</a><br>从JVM到Dalivk再到ART <a href="https://blog.csdn.net/stven_king/article/details/102620708">https://blog.csdn.net/stven_king/article/details/102620708</a></p><div>    <section id="comments" class="comments">        <style>            .utterances{max-width: 100%;}        </style>        <script             src="https://utteranc.es/client.js"            repo="BongmiTeam/BongmiTeam.github.io"            issue-term="pathname"            label="Comment"            theme="boxy-light"            crossorigin="anonymous"            async>        </script>    </section></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式高频考点&lt;第一季&gt;</title>
      <link href="/2022/03/02/design-patter/"/>
      <url>/2022/03/02/design-patter/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式高频考点-lt-第一季-gt"><a href="#设计模式高频考点-lt-第一季-gt" class="headerlink" title="设计模式高频考点&lt;第一季&gt;"></a>设计模式高频考点&lt;第一季&gt;</h2><p>本文带有很浓重的主观色彩，有不同观点是非常正常的，欢迎指正。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>设计模式是干什么的？</p></li><li><p>设计原则「道」</p><ul><li>单一职责原则 (Single Responsibility Principle)</li><li>开放-关闭原则 (Open-Closed Principle)</li></ul></li><li><p>设计模式「术」</p><ul><li>代理模式</li><li>享元模式</li><li>迭代器模式</li></ul></li></ul><h2 id="设计模式是干什么的？"><a href="#设计模式是干什么的？" class="headerlink" title="设计模式是干什么的？"></a>设计模式是干什么的？</h2><p>产品设计，就是尽可能让用户用得更舒服。不严谨的说，我们的OOP设计模式，就是尽可能让你写的代码（大部分情况是类Class）尽可能让你的「同事」包括自己用的舒服。</p><p>产品、外观、OOP对于好的设计有很多共同点，比如：简单，干净，不会绕来绕去。</p><p>设计模式中「模式」二字，代表类的设计是有「道」和「术」的规律可循的。<br><img src="/images/remote.jpeg"></p><h2 id="设计原则「道」（2-7）"><a href="#设计原则「道」（2-7）" class="headerlink" title="设计原则「道」（2/7）"></a>设计原则「道」（2/7）</h2><h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则 (Single Responsibility Principle)"></a>单一职责原则 (Single Responsibility Principle)</h3><p>一句话：越简单越幸福。你起了一个类名LoginViewController，那你最好别做和Login无关的事情。</p><p>反例1：Register和Login的VC界面很像，只有部分不一样，这个时候比较糟糕的做法就：</p><pre><code>class LoginViewController &#123;  enum Type &#123;  case login  case register  &#125;  var type: Type = .login  func doSomething1() &#123;    if type == .login &#123;      /*.login 时的逻辑..*/    &#125; else &#123;      /*.register 时的逻辑..*/    &#125;  &#125;  func doSomething2() &#123;    if type == .login &#123;      /*.login 时的逻辑..*/    &#125; else &#123;      /*.register 时的逻辑..*/    &#125;  &#125;&#125;</code></pre><p>LoginViewController 承担了注册和登录的职责，显然是不满足单一原则的。</p><p>显而易见的缺陷：</p><ul><li>改login的逻辑的时候会影响到register，改register的时候会影响到login，「测试需要两个界面都测试，更容易出bug」。</li><li>随着业务的发展，login和regitser的业务可能会越来越不同，这个时候只能在代码里加更多的if 分支去写逻辑。</li></ul><p>解决方案：</p><ul><li>不太好，但我个人觉得比上面例子要好的办法，直接把LoginViewController复制一份改名RegisterViewController，各写各的逻辑，这样至少能保证改代码的时候不会互相影响。</li><li>⭐️把UI/逻辑相似部分抽取出来，封装成一个个类。（有时候赶项目的时候不一定有时间做这个工作）</li><li>或者，有什么更好的办法吗？</li></ul><h3 id="开放-关闭原则-Open-Closed-Principle"><a href="#开放-关闭原则-Open-Closed-Principle" class="headerlink" title="开放-关闭原则 (Open-Closed Principle)"></a>开放-关闭原则 (Open-Closed Principle)</h3><p>修改/新增一个功能，「尽可能」不用动到原来的代码，视情况而定。</p><p><img src="/images/xiaobawang.png"><br><img src="/images/rus.png"></p><p>图1小霸王游戏只要换卡就行了，图2俄罗斯方块换游戏的话要修改主板里的代码。。。显然小霸王更复合「开闭原则」</p><p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><p>举一个商城这边的实际例子：</p><p>1、上传订单信息到棒糖服务器，服务器下发一个pid。</p><p>2、调用支付宝sdk，并把pid传给支付宝sdk。</p><p>很容易得到这样的伪代码</p><pre><code>class func Payment &#123;  private var alipaySdk = AlipaySDK()  init() &#123;    alipaySdk.delegate = self  &#125;  func pay(with order: OrderInfo) &#123;    let request = BMRequest(order: order)    request.start &#123; pid      alipaySdk.pay(amount: order.amount,                    pid: pid)    &#125;  &#125;  // 支付宝的回调用  func alipay(_ sdk, status: ...)  func alipay(_ sdk, userInfo: ...)&#125;</code></pre><p><img src="/images/pay1.jpeg"></p><p>如果现在要加一个微信呢？你不得不在原来代码上做修改，pay方法很可能会变成这样。</p><pre><code>class func Payment &#123;  private var wechatSdk = WeChatSDK() // 😓新增  private var alipaySdk = AlipaySDK()  init() &#123;    alipaySdk.delegate = self    wechatSdk.delegate = self  &#125;  // ❌修改代码  func pay(with order: OrderInfo, type: PayType) &#123;    let request = BMRequest(order: order)    request.start &#123; pid      // ❌修改代码      if (type == .alipay) &#123;        alipaySdk.pay(amount: order.amount,                          pid: pid)      &#125; else if (type == .wechat) &#123;        wechatSdk.pay(amount: order.amount,                          pid: pid)      &#125;    &#125;  &#125;  // 支付宝的回调用  func alipay(_ sdk, status: ...)  func alipay(_ sdk, userInfo: ...)  // 😓新增代码  func wechat(_ sdk, status: ...)  func wechat(_ sdk, userInfo:...)&#125;</code></pre><p>如果要加一个京东支付，我们还得继续在源代码上修改</p><p>我们的做法：</p><p><img src="/images/pay2.jpeg"></p><pre><code>protocol PaySdk &#123;  pay(amount: Int, pid: Int)&#125;class Alipay: PaySdk &#123;  func pay(amount: Int, pid: Int) &#123;    ...支付报相关的逻辑  &#125;    // 支付宝的回调用  func alipay(_ sdk, status: ...)  func alipay(_ sdk, userInfo: ...)&#125;class WeCheat: PaySdk &#123;  func pay(amount: Int, pid: Int) &#123;    ...微信支付逻辑  &#125;  // 微信回调用  func wechat(_ sdk, status: ...)  func wechat(_ sdk, userInfo:...)&#125;class Payment &#123;  private sdk: PaySdk!  init(sdk: PaySdk) &#123;    self.sdk = sdk  &#125;  func pay(with order: OrderInfo) &#123;    let request = BMRequest(order: order)    request.start &#123; pid      sdk.pay(amount: order.amount,                        pid: pid)    &#125;&#125;//  使用let alipay = Payment(sdk: Alipay())alipay.pay(amount: ...)let wechatPay = Payment(sdk: WeCheat())wechatPay.pay(amount: ...)</code></pre><p>之后如果要再来一个京东支付</p><p>你只要实现PaySdk 这个协议即可：</p><pre><code>class JdPay: PaySdk &#123;  func pay(amount: Int, pid: Int) &#123;    ...京东支付逻辑  &#125;  // 京东的回调  func jd(_ sdk, status: ...)  func jd(_ sdk, userInfo:...)&#125;// 使用let jdpay = Payment(sdk: JdPay())jdpay.pay(amount: ...)</code></pre><p>新增功能写「新代码」，不需要改老代码，做到了开闭原则。</p><h2 id="设计模式「术」-lt-3-23-gt"><a href="#设计模式「术」-lt-3-23-gt" class="headerlink" title="设计模式「术」&lt;3/23&gt;"></a>设计模式「术」&lt;3/23&gt;</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>官方说法：为其他对象提供一种代理以控制对这个对象的访问。</p><p>想想我们的科学上网，就是代理模式.</p><p>假如我们访问YouTube，只发了一个POST请求，过程如下：</p><p>上行：客户端发起请求 —-&gt; 代理服务器——&gt; Youtube服务器</p><p>下行：Youtube服务器 —–&gt; 代理服务器——&gt; 客户端</p><p>下面还是来一个实际例子：</p><pre><code>protocol User &#123;  var isPrime: Bool &#123; set get &#125;  func syncToServer()&#125;class FemometerUser: User &#123;  var isPrime: Bool  init(_ isPrime: Bool) &#123;    self.isPrime = isPrime  &#125;  func syncToServer() &#123;    // .. 服务器..  &#125;&#125;</code></pre><p>假设iOS没有 KVO功能，我们想监听isPrime属性的改变，但是又不想改动原来FemometerUser、User的代码，该怎么做呢？</p><pre><code>protocol User &#123;  var isPrime: Bool &#123; set get &#125;  func syncToServer()&#125;class FemometerUser: User &#123;  var isPrime: Bool  init(_ isPrime: Bool) &#123;    self.isPrime = isPrime  &#125;  func syncToServer() &#123;    // .. 服务器..  &#125;&#125;// 代理class UserIsPrimeObserverProxy: User &#123;  private var target: User // 真实对象  public var isPrimeDidChanged: ((Bool) -&gt; Void)?  var isPrime: Bool &#123;    set &#123;      // 转发给真实的对象, 可以加一些自己的逻辑      if newValue == target.isPrime &#123;        // 去重        return      &#125;      target.isPrime = newValue      isPrimeDidChanged?(newValue)    &#125;    get &#123;      // 从真实的对象中获取价值      return target.isPrime    &#125;  &#125;  func syncToServer() &#123;    // 转发给真实的对象    target.syncToServer()  &#125;  init(_ target: User) &#123;    self.target = target  &#125;&#125;</code></pre><p>使用：</p><pre><code>let user = FemometerUser(false)let observerProxy = UserIsPrimeObserverProxy(user)observerProxy.isPrimeDidChanged = &#123; newValue in  print(&quot;change:\(newValue)&quot;)&#125;// 使用代理访问observerProxy.isPrime = falseobserverProxy.isPrime = trueobserverProxy.isPrime = trueobserverProxy.isPrime = trueobserverProxy.isPrime = false// 使用代理访问同步服务器的方法observerProxy.syncToServer()// 输出change:truechange:false</code></pre><p>下面是KVO的官方实现原理图，运用了isa_hook实现对象级别的hook实现的，其本质还是代理模式。</p><p><img src="/images/proxy.png"></p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>运用共享技术有效地支持大量细粒度的对象。</p><p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p><p>享元模式在Java标准库中有很多应用。我们知道，包装类型如Byte、Integer都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以Integer为例，如果我们通过Integer.valueOf()这个静态工厂方法创建Integer实例，当传入的int范围在-128~+127之间时，会直接返回缓存的Integer实例：</p><pre><code>public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        Integer n1 = Integer.valueOf(100);        Integer n2 = Integer.valueOf(100);        System.out.println(n1 == n2); // true 说明地址相同    &#125;&#125;</code></pre><p>想想我们的UITableView的复用机制，是不是用的享元模式？</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>官方说法：<strong>迭代器模式</strong>是一种行为设计模式，让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><p>还是来一个fm实际例子，我们想实现一个这样的开发体验</p><pre><code>let body1 = BodyStatus(type: .bbt, id: 1)let body2 = BodyStatus(type: .period, id: 2)let body3 = BodyStatus(type: .bbt, id: 3)let body4 = BodyStatus(type: .bbt, id: 4)let body5 = BodyStatus(type: .period, id: 5)let body6 = BodyStatus(type: .bbt, id: 6)let seq = PeroidSequence(origin: [body1,                                  body2,                                  body3,                                  body4,                                  body5,                                  body6])                                  for i in seq &#123;  print(i.id)&#125;// 输出结果 为 2 和 5</code></pre><p>​    </p><p>下面是实现方法</p><pre><code>struct PeroidSequence: Sequence &#123;  let origin: [BodyStatus]  func makeIterator() -&gt; PeriodIterator &#123;    return PeriodIterator(self)  &#125;&#125;struct PeriodIterator: IteratorProtocol &#123;  typealias Element = BodyStatus  private var index = 0  private let seq: PeroidSequence  init(_ seq: PeroidSequence) &#123;    self.seq = seq  &#125;  mutating func next() -&gt; BodyStatus? &#123;    let count = seq.origin.count    while (index &lt; count &amp;&amp; seq.origin[index].type != .period) &#123;      index += 1    &#125;    if index &gt;= count &#123;      return nil    &#125;    let result = seq.origin[index]    index += 1    return result  &#125;&#125;</code></pre><p>可以看到，我们我们把「访问type为period的bodystatus的逻辑」封装起来了，下次使用只要用「更加优雅」for ..in 就可以了，不需要每次在for循环里做判断。</p><p>此外，我们还可以为类似二叉树这样的非线性结构创建不同的迭代器，例如：创建一个「先序遍历迭代器」和 「层次遍历迭代器」，原理同上就不写具体代码了。<br><img src="/images/tree_vis.jpeg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>同事就是你的用户，互相给一些feedback吧。</p><div>    <section id="comments" class="comments">        <style>            .utterances{max-width: 100%;}        </style>        <script             src="https://utteranc.es/client.js"            repo="BongmiTeam/BongmiTeam.github.io"            issue-term="pathname"            label="Comment"            theme="boxy-light"            crossorigin="anonymous"            async>        </script>    </section></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>曲线模块入门</title>
      <link href="/2022/02/18/chart-begin/"/>
      <url>/2022/02/18/chart-begin/</url>
      
        <content type="html"><![CDATA[<h1 id="Charts-0-简单入门篇"><a href="#Charts-0-简单入门篇" class="headerlink" title="Charts - 0 - 简单入门篇"></a>Charts - 0 - 简单入门篇</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>简介</li><li>画出你自己想要的曲线，回到梦开始的地方</li><li>一些奇技淫巧</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/mcconkiee/ios-charts">https://github.com/mcconkiee/ios-charts</a></p><ul><li>Xcode 6.3 / Swift 1.2</li><li>iOS 7.0 (Drag .swift files to your project)</li><li>iOS 8.0 (Use as an <strong>Embedded</strong> Framework)</li></ul><p>I’ve chosen to write it in <code>Swift</code> as it can be highly optimized by the compiler, and can be used in both <code>Swift</code> and <code>ObjC</code> project. The demo project is written in <code>ObjC</code> to demonstrate how it works.</p><p><strong>An amazing feature of this library now, both Android and iOS</strong>, is the time it saves you when developing for both platforms, as the learning curve is singleton- it happens only once, and the code stays very similar so developers don’t have to go around and re-invent the app to produce the same output with a different library. (And that’s not even considering the fact that there’s not really another good choice out there currently…) </p><p>总结：</p><ul><li>安卓有对应的框架。</li><li>支持 <code>oc</code> 和 <code>Swift</code> 开发。</li><li>更多详细内容去上面官方地址查看。</li></ul><h2 id="画出你自己想要的曲线，回到梦开始的地方"><a href="#画出你自己想要的曲线，回到梦开始的地方" class="headerlink" title="画出你自己想要的曲线，回到梦开始的地方"></a>画出你自己想要的曲线，回到梦开始的地方</h2><p>这是Fasting App中统计一日三餐情况的图表，也是一个最简单的例子，包含了大部分你想要的东西。</p><img src="/images/chart_0_1.jpeg" width="300" height="250" /><p><strong>第一步，看看UI稿，看看自己和Charts中哪一种图表类比较接近。</strong></p><img src="/images/chart_0_2.jpeg" width="470" height="580"  /><p>我这里显然是ScatterChart</p><p><strong>第二步，初始化你的类，以及一些初始参数，这里我只写一些重要的。</strong></p><pre><code>public lazy var chart: ScatterChartView = &#123;  let view = ScatterChartView()  view.clipsToBounds = false  return view&#125;()chart.leftAxis.axisMinimum = 0 // y轴最小值chart.leftAxis.axisMaximum = 24 * 60 * 60 // y轴最大值，一天24小时的秒数chart.xAxis.valueFormatter = ChartXAxisFormatter() // x轴的显示格式，后面会自定义写一个chart.xAxis.drawLabelsEnabled = true // 是否显示x轴底部坐标信息chart.xAxis.labelPosition = .bottom // x轴坐标信息显示位置chart.setVisibleXRangeMaximum(Double(7)) // 一页显示多少个，这里是每周一页，所以是7</code></pre><p><strong>第三步，自定义x轴坐标显示信息。</strong></p><p>正常x轴当然是显示数字，我们这边需要自定义显示成 S M T W 这种周期缩写，你需要自己实现一个前面提到的Formatter，代码如下：</p><pre><code>private class ChartXAxisFormatter: NSObject, IAxisValueFormatter &#123;  func stringForValue(_ value: Double, axis: AxisBase?) -&gt; String &#123;    let weeks = [&quot;S&quot;,&quot;M&quot;,&quot;T&quot;,&quot;W&quot;,&quot;T&quot;,&quot;F&quot;,&quot;S&quot;]    let v = Int(value)    return weeks[v % weeks.count]  &#125;&#125;</code></pre><p>显然，你可以在stringForValue做超高自由度的映射。</p><p><strong>第四步，绘制你想要的图形。</strong></p><p>在第一张图中我标了一些红圈，它们都是通过Render绘制出来的，我们来捋一下需要做的事情。</p><ul><li><p>A、默认的柱子是一个长方形的，没有圆角，我们需要在它的上下部分各画一个圆。</p></li><li><p>B、需要把早中晚三种图标绘制到曲线制定位置上。</p></li></ul><p>对于A：</p><p>首先先编写一个XAxisRenderer：</p><pre><code>open class BMFTTrendDietXaxisRenderer: XAxisRenderer &#123;  open override func drawGridLine(context: CGContext, x: CGFloat, y: CGFloat) &#123;    if x &gt;= viewPortHandler.offsetLeft        &amp;&amp; x &lt;= viewPortHandler.chartWidth &#123;      guard let xAxis = self.axis as? XAxis else &#123; return &#125;      let halfGridLineWidth = xAxis.gridLineWidth / 2.0      context.beginPath()      context.move(to: CGPoint(x: x, y: viewPortHandler.contentTop + halfGridLineWidth))      context.addLine(to: CGPoint(x: x, y: viewPortHandler.contentBottom - halfGridLineWidth))      context.strokePath()      context.setFillColor(xAxis.gridColor.cgColor)      // 上半圆      context.fillEllipse(in: CGRect(x: x - halfGridLineWidth,                                     y: viewPortHandler.contentTop,                                     width: xAxis.gridLineWidth,                                     height: xAxis.gridLineWidth))      // 下半圆      print(viewPortHandler.contentBottom)      context.fillEllipse(in: CGRect(x: x - halfGridLineWidth,                                     y: viewPortHandler.contentBottom - xAxis.gridLineWidth,                                     width: xAxis.gridLineWidth,                                     height: xAxis.gridLineWidth))    &#125;  &#125;&#125;</code></pre><p>老实说，里面具体逻辑我有点记不清了。不过你只要理解，Chart之后会通过这个类来绘制图中的长方形小柱子就可以了。接着我们还需要手动告诉chart用这个类来绘制小柱子：</p><pre><code>chart.xAxisRenderer = BMFTTrendDietXaxisRenderer(viewPortHandler: renderer.viewPortHandler, xAxis:chart.xAxis, transformer: renderer.transformer)</code></pre><p>对于B：</p><p>首先也是编写一个Renderer</p><pre><code>open class BMFTTrendRenderer: NSObject, IShapeRenderer &#123;  public var image: CGImage?  init(image: CGImage?) &#123;    super.init()    self.image = image  &#125;  open func renderShape(    context: CGContext,    dataSet: IScatterChartDataSet,    viewPortHandler: ViewPortHandler,    point: CGPoint,    color: NSUIColor) &#123;    let shapeSize = dataSet.scatterShapeSize    let shapeHalf = shapeSize / 2.0    let shapeHoleSizeHalf = dataSet.scatterShapeHoleRadius    let shapeHoleSize = shapeHoleSizeHalf * 2.0    let shapeHoleColor = dataSet.scatterShapeHoleColor    let shapeStrokeSize = (shapeSize - shapeHoleSize) / 2.0    let shapeStrokeSizeHalf = shapeStrokeSize / 2.0        var rect = CGRect()    rect.origin.x = point.x - shapeHalf    rect.origin.y = point.y - shapeHalf    rect.size.width = 23    rect.size.height = 23        if let image = self.image &#123;      context.drawFlipped(image, in: rect)    &#125;  &#125;&#125;extension CGContext &#123;  /// Draw `image` flipped vertically, positioned and scaled inside `rect`.  public func drawFlipped(_ image: CGImage, in rect: CGRect) &#123;    self.saveGState()    self.translateBy(x: 0, y: rect.origin.y + rect.height)    self.scaleBy(x: 1.0, y: -1.0)    draw(image, in: CGRect(origin: CGPoint(x: rect.origin.x, y: 0), size: rect.size), byTiling: false)    self.restoreGState()  &#125;&#125;</code></pre><p>这里根据point把自定义的图标绘制到指定位置上，最后在设置数据集的时候，说明使用这个render绘制：</p><pre><code>chartDataSet1.shapeRenderer = BMFTTrendRenderer(image: &quot;breakfast_trendz&quot;.image?.cgImage)chartDataSet2.shapeRenderer = BMFTTrendRenderer(image: &quot;lunch_trends&quot;.image?.cgImage)chartDataSet3.shapeRenderer = BMFTTrendRenderer(image: &quot;dinner_trends&quot;.image?.cgImage)</code></pre><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>我在Femometer 的横屏曲线里看到过一些奇技淫巧，比如说前面我们讲的自定义图标，它没有自己写render，而是计算相应point，自己创建一个UIImagView直接盖上去。这样写效果上没什么问题，不过如果需要支持翻页的话就凉了。</p><div>    <section id="comments" class="comments">        <style>            .utterances{max-width: 100%;}        </style>        <script             src="https://utteranc.es/client.js"            repo="BongmiTeam/BongmiTeam.github.io"            issue-term="pathname"            label="Comment"            theme="boxy-light"            crossorigin="anonymous"            async>        </script>    </section></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透教程</title>
      <link href="/2022/02/18/ngrok/"/>
      <url>/2022/02/18/ngrok/</url>
      
        <content type="html"><![CDATA[<p>ngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以ngrok可以很方便地协助服务端程序测试。</p><h3 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a><strong>如何安装？</strong></h3><ol><li>进入ngrok官网（ngrok.com）并注册ngrok账号。</li></ol><p><img src="/images/Aspose.Words.78114620-64f0-45f4-8fc1-f8f4f6c6a4d3.001.png"></p><ol><li>下载ngrok，m1芯片请选择arm64版本。</li><li>解压下载到的安装包，双击可执行文件安装。</li></ol><p><img src="/images/Aspose.Words.78114620-64f0-45f4-8fc1-f8f4f6c6a4d3.002.png"></p><p><img src="/images/Aspose.Words.78114620-64f0-45f4-8fc1-f8f4f6c6a4d3.003.png"></p><ol><li>安装好后回到官网，点击左边的Your Authtoken ，复制自己的授权码到~/ngrok2/ngrok.yml文件下，格式如下图。</li></ol><p><img src="/images/Aspose.Words.78114620-64f0-45f4-8fc1-f8f4f6c6a4d3.004.png"></p><ol><li>至此准备工作完毕，现在开始进行内网穿透，首先打开nginx对应项目的配置文件，以miscs.bongmi.com为例，将配置文件中的80端口改为81（因为80端口被fis3.bongmi.com占用，内网穿透时外网只能看到fis3.bongmi.com下的资源）。</li><li>然后打开终端，执行nginx -s reolod 重启nginx服务。再执行ngrok http 81，将81端口暴露到外网，运行成功则如下所示。</li></ol><p><img src="/images/Aspose.Words.78114620-64f0-45f4-8fc1-f8f4f6c6a4d3.005.png"></p><ol><li>现在就可以通过红框中的Forwarding对应的http协议和https协议网址从外网访问到81端口下的资源了，Web Interface 是后台，可以看到访问日志。</li></ol><div>    <section id="comments" class="comments">        <style>            .utterances{max-width: 100%;}        </style>        <script             src="https://utteranc.es/client.js"            repo="BongmiTeam/BongmiTeam.github.io"            issue-term="pathname"            label="Comment"            theme="boxy-light"            crossorigin="anonymous"            async>        </script>    </section></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在棒糖如何写博客</title>
      <link href="/2021/11/10/hello-world/"/>
      <url>/2021/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下说明仅供棒糖科技内部员工参考, 用来引导团队成员配置个人环境以及编写发布博文</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="1-安装-nodejs"><a href="#1-安装-nodejs" class="headerlink" title="1. 安装 nodejs"></a>1. 安装 nodejs</h3><p>参考: <a href="https://nodejs.org/zh-cn/">nodejs.org</a></p><h3 id="2-克隆项目"><a href="#2-克隆项目" class="headerlink" title="2. 克隆项目"></a>2. 克隆项目</h3><p><code>$ git clone git@[bongmi-gitlab-host]:bongmi/bongmi-blog.git</code></p><h3 id="3-初始化博客的运行环境"><a href="#3-初始化博客的运行环境" class="headerlink" title="3. 初始化博客的运行环境"></a>3. 初始化博客的运行环境</h3><p><code>$ sh manager.sh ensure_env</code></p><h3 id="4-开通权限"><a href="#4-开通权限" class="headerlink" title="4. 开通权限"></a>4. 开通权限</h3><p>将 github 账号提供给 <a href="mailto:&#x68;&#97;&#110;&#108;&#x69;&#x6e;&#103;&#x40;&#98;&#x6f;&#x6e;&#103;&#109;&#105;&#46;&#99;&#x6f;&#109;">&#x68;&#97;&#110;&#108;&#x69;&#x6e;&#103;&#x40;&#98;&#x6f;&#x6e;&#103;&#109;&#105;&#46;&#99;&#x6f;&#109;</a> 并接受邀请</p><h2 id="编辑与发布"><a href="#编辑与发布" class="headerlink" title="编辑与发布"></a>编辑与发布</h2><h3 id="1-新建一篇博文"><a href="#1-新建一篇博文" class="headerlink" title="1. 新建一篇博文"></a>1. 新建一篇博文</h3><p><code>$ sh manager.sh new [file_name]</code></p><h3 id="2-编辑博文"><a href="#2-编辑博文" class="headerlink" title="2. 编辑博文"></a>2. 编辑博文</h3><p><code>$ sh manager.sh edit [file_name]</code></p><h3 id="3-本地实时预览博客"><a href="#3-本地实时预览博客" class="headerlink" title="3. 本地实时预览博客"></a>3. 本地实时预览博客</h3><p><code>$ sh manager.sh run</code></p><h3 id="4-发布你写的文章"><a href="#4-发布你写的文章" class="headerlink" title="4. 发布你写的文章"></a>4. 发布你写的文章</h3><p><code>$ sh manager deploy</code></p><div>    <section id="comments" class="comments">        <style>            .utterances{max-width: 100%;}        </style>        <script             src="https://utteranc.es/client.js"            repo="BongmiTeam/BongmiTeam.github.io"            issue-term="pathname"            label="Comment"            theme="boxy-light"            crossorigin="anonymous"            async>        </script>    </section></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
