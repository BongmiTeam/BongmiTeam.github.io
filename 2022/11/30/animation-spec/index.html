<!DOCTYPE html><html lang="en"><head><title>Compose动画学习之AnimationSpec</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>Compose动画学习之AnimationSpec</h1><div class="time">2022-11-30 by yaoxiawen</div><p>在compose动画的学习使用过程中，有一个参数属性一直存在，那就是AnimationSpec。不管是用于为单个值添加动画效果的animate*AsState，还是用于为多个值添加动画效果的updateTransition，亦或是一些封装好的高级别动画API：animatedContentSize、AnimatedVisibility，在这些里面都存在着AnimationSpec这个参数属性。但如果你并不了解并不会使用AnimationSpec，也不会阻碍你使用这些动画API，因为这些动画API都提供了默认的AnimationSpec实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface AnimationSpec&lt;T&gt; &#123;</span><br><span class="line">    fun &lt;V : AnimationVector&gt; vectorize(</span><br><span class="line">        converter: TwoWayConverter&lt;T, V&gt;</span><br><span class="line">    ): VectorizedAnimationSpec&lt;V&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnimationSpec，the specification of an animation，是一个接口，它用来存储动画规格，包括要进行动画处理的数据类型、将数据转换为动画后将使用的动画配置。<br>Compose已经为我们实现了一些常用的AnimationSpec。<br><img src="/images/animationspec.jpeg" alt="AnimationSpec"><br>官方提供了8种可以直接使用的(蓝色标注的为类，可以直接使用)。</p>
<h2 id="SpringSpec"><a href="#SpringSpec" class="headerlink" title="SpringSpec"></a>SpringSpec</h2><p>SpringSpec，弹性动画，是许多动画的默认AnimationSpec实现，例如animate*AsState、updateTransition、animatedContentSize等这些动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; spring(</span><br><span class="line">    dampingRatio: Float = Spring.DampingRatioNoBouncy,</span><br><span class="line">    stiffness: Float = Spring.StiffnessMedium,</span><br><span class="line">    visibilityThreshold: T? = null</span><br><span class="line">): SpringSpec&lt;T&gt; =</span><br><span class="line">    SpringSpec(dampingRatio, stiffness, visibilityThreshold)</span><br></pre></td></tr></table></figure>
<p>官方提供了spring()方法用于构造SpringSpec，接收三个参数，但都有其默认值。</p>
<ul>
<li>dampingRatio：阻尼比，默认值为Spring.DampingRatioNoBouncy = 1f，也就是没有弹性。当阻尼比&lt;1时，阻尼比越低，弹簧越有弹性。</li>
<li>stiffness：刚度，默认值为Spring.StiffnessMedium。</li>
<li>visibilityThreshold：可见性阈值。</li>
</ul>
<p>dampingRatio和stiffness都各有5个枚举值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun SpringDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = spring(</span><br><span class="line">            dampingRatio = Spring.DampingRatioNoBouncy,</span><br><span class="line">            stiffness = Spring.StiffnessHigh</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-spring&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个size大小动画来观察SpringSpec效果，修改上述代码的spring中参数可以观察到各种SpringSpec效果，在同样的dampingRatio = Spring.DampingRatioNoBouncy，也就是没有弹性时，刚度越小，动画时间越长，动画效果越明显。而在较低的刚度下，阻尼比越小，弹性动画效果就越明显。</p>
<h2 id="TweenSpec"><a href="#TweenSpec" class="headerlink" title="TweenSpec"></a>TweenSpec</h2><p>TweenSpec，用来创建使用给定的持续时间、延迟时间和缓和曲线配置的动画规格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; tween(</span><br><span class="line">    durationMillis: Int = DefaultDurationMillis,</span><br><span class="line">    delayMillis: Int = 0,</span><br><span class="line">    easing: Easing = FastOutSlowInEasing</span><br><span class="line">): TweenSpec&lt;T&gt; = TweenSpec(durationMillis, delayMillis, easing)</span><br></pre></td></tr></table></figure>
<p>官方提供了tween()方法用于构造TweenSpec，接收三个参数，但都有其默认值。</p>
<ul>
<li>durationMillis：动画持续时间，默认值为300毫秒。</li>
<li>delayMillis：动画延迟时间，默认值为0，也就是立即开始动画。</li>
<li>easing：动画曲线变化，默认值为FastOutSlowInEasing</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun interface Easing &#123;</span><br><span class="line">    fun transform(fraction: Float): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Easing是一个接口，是一种调整动画分数的方法，允许过渡元素加速或减速，而不是以恒定的速度移动，Easing中有一个方法，方法中参数 fraction 是一个在0到1.0之间的值，表示动画中的当前进度点，其中0表示开始，1.0表示结束。<br>Easing只有一个实现类CubicBezierEasing，CubicBezierEasing实现了三阶贝塞尔曲线。官方推荐与其创建新实例，不如考虑使用一种常见的 cubic Easings。<br>官方提供4种常用的Easing实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//以静止开始和结束的元素使用此标准缓动。 他们快速加速并逐渐减速，以强调过渡的结束。这是最常见的方式。这相当于原生安卓插值器FastOutSlowInInterpolator</span><br><span class="line">val FastOutSlowInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f)</span><br><span class="line">//传入的元素使用减速缓动进行动画处理，它以峰值速度（元素运动的最快点）开始过渡并在静止时结束。这相当于原生安卓插值器LinearOutSlowInInterpolator</span><br><span class="line">val LinearOutSlowInEasing: Easing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f)</span><br><span class="line">//退出屏幕的元素使用加速缓动，它们从静止开始并以峰值速度结束。这相当于原生安卓插值器FastOutLinearInInterpolator</span><br><span class="line">val FastOutLinearInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 1.0f, 1.0f)</span><br><span class="line">//线性、匀速缓动</span><br><span class="line">val LinearEasing: Easing = Easing &#123; fraction -&gt; fraction &#125;</span><br></pre></td></tr></table></figure>
<p>我们将SpringSpec中的案例使用spring改为使用tween来观察TweenSpec效果，修改代码的tween中参数可以观察到各种TweenSpec效果。为了能更好的观察到动画效果，可以将动画时间适当设置长一点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun TweenDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = tween(</span><br><span class="line">            durationMillis = 3000,</span><br><span class="line">            easing = FastOutSlowInEasing</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-tween&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SnapSpec"><a href="#SnapSpec" class="headerlink" title="SnapSpec"></a>SnapSpec</h2><p>SnapSpec，描述了一种跳切类型的动画。 它立即将动画值捕捉到最终值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; snap(delayMillis: Int = 0) = SnapSpec&lt;T&gt;(delayMillis)</span><br></pre></td></tr></table></figure>
<p>官方提供了snap()方法用于构造SnapSpec，只有一个参数，delayMillis：动画延迟时间，默认值为0，也就是立即开始动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Immutable</span><br><span class="line">class SnapSpec&lt;T&gt;(val delay: Int = 0) : DurationBasedAnimationSpec&lt;T&gt; &#123;</span><br><span class="line">    override fun &lt;V : AnimationVector&gt; vectorize(</span><br><span class="line">        converter: TwoWayConverter&lt;T, V&gt;</span><br><span class="line">    ): VectorizedDurationBasedAnimationSpec&lt;V&gt; = VectorizedSnapSpec(delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SnapSpec实现了DurationBasedAnimationSpec接口，还有上面已经介绍过的TweenSpec也是实现了DurationBasedAnimationSpec接口，此外还有KeyframesSpec。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Immutable</span><br><span class="line">class TweenSpec&lt;T&gt;(</span><br><span class="line">    val durationMillis: Int = DefaultDurationMillis,</span><br><span class="line">    val delay: Int = 0,</span><br><span class="line">    val easing: Easing = FastOutSlowInEasing</span><br><span class="line">) : DurationBasedAnimationSpec&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    override fun &lt;V : AnimationVector&gt; vectorize(converter: TwoWayConverter&lt;T, V&gt;) =</span><br><span class="line">        VectorizedTweenSpec&lt;V&gt;(durationMillis, delay, easing)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface DurationBasedAnimationSpec&lt;T&gt; : FiniteAnimationSpec&lt;T&gt; &#123;</span><br><span class="line">    override fun &lt;V : AnimationVector&gt; vectorize(converter: TwoWayConverter&lt;T, V&gt;):</span><br><span class="line">        VectorizedDurationBasedAnimationSpec&lt;V&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DurationBasedAnimationSpec，描述了基于固定持续时间的 AnimationSpecs，例如 KeyframesSpec、TweenSpec 和 SnapSpec。 这些基于持续时间的AnimationSpec在放入RepeatableSpec时可以重复执行。</p>
<p>我们将上面的案例改为使用snap来观察SnapSpec效果，将动画延迟1秒来观察snap跳切的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun SnapDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = snap(</span><br><span class="line">            delayMillis = 1000</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-snap&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KeyframesSpec"><a href="#KeyframesSpec" class="headerlink" title="KeyframesSpec"></a>KeyframesSpec</h2><p>KeyframesSpec，基于动画持续时间中不同时间戳定义的值（即不同的关键帧）来制作动画。每个关键帧都可以使用KeyframesSpecConfig.at来进行定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; keyframes(</span><br><span class="line">    init: KeyframesSpec.KeyframesSpecConfig&lt;T&gt;.() -&gt; Unit</span><br><span class="line">): KeyframesSpec&lt;T&gt; &#123;</span><br><span class="line">    return KeyframesSpec(KeyframesSpec.KeyframesSpecConfig&lt;T&gt;().apply(init))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方提供了keyframes()方法用于构造KeyframesSpec，只有一个参数KeyframesSpec.KeyframesSpecConfig。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class KeyframesSpecConfig&lt;T&gt; &#123;</span><br><span class="line">    //动画持续时间，默认为300</span><br><span class="line">    var durationMillis: Int = DefaultDurationMillis</span><br><span class="line"></span><br><span class="line">    //动画延迟时间，默认为0</span><br><span class="line">    var delayMillis: Int = 0</span><br><span class="line"></span><br><span class="line">    //关键帧</span><br><span class="line">    internal val keyframes = mutableMapOf&lt;Int, KeyframeEntity&lt;T&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    //添加一个关键帧在某个时间点时刻</span><br><span class="line">    infix fun T.at(/*@IntRange(from = 0)*/ timeStamp: Int): KeyframeEntity&lt;T&gt; &#123;</span><br><span class="line">        return KeyframeEntity(this).also &#123;</span><br><span class="line">            keyframes[timeStamp] = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加一个关键帧在某个进度时刻</span><br><span class="line">    infix fun T.atFraction(fraction: Float): KeyframeEntity&lt;T&gt; &#123;</span><br><span class="line">        return at((durationMillis * fraction).roundToInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为刚提供的时间戳开始的时间间隔添加 Easing</span><br><span class="line">    infix fun KeyframeEntity&lt;T&gt;.with(easing: Easing) &#123;</span><br><span class="line">        this.easing = easing</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>KeyframesSpecConfig存储关键帧的可变配置，包括 durationMillis、delayMillis 和所有关键帧。 每个关键帧都定义了特定时间的动画值。<br>看一下具体使用和效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun KeyframesDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = keyframes &#123;</span><br><span class="line">            durationMillis = 1000</span><br><span class="line">            50.dp at 0 with LinearOutSlowInEasing</span><br><span class="line">            60.dp at 100 with FastOutLinearInEasing</span><br><span class="line">            70.dp at 300</span><br><span class="line">            80.dp at 600</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-keyframes&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RepeatableSpec"><a href="#RepeatableSpec" class="headerlink" title="RepeatableSpec"></a>RepeatableSpec</h2><p>RepeatableSpec，构建一个基于DurationBasedAnimationSpec的重复动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; repeatable(</span><br><span class="line">    iterations: Int,</span><br><span class="line">    animation: DurationBasedAnimationSpec&lt;T&gt;,</span><br><span class="line">    repeatMode: RepeatMode = RepeatMode.Restart,</span><br><span class="line">    initialStartOffset: StartOffset = StartOffset(0)</span><br><span class="line">): RepeatableSpec&lt;T&gt; =</span><br><span class="line">    RepeatableSpec(iterations, animation, repeatMode, initialStartOffset)</span><br></pre></td></tr></table></figure>
<p>官方提供了repeatable()方法用于构造RepeatableSpec，四个参数，需要至少传入两个参数。</p>
<ul>
<li>iterations：重复次数，理论上应大于1，等于1表示不重复，也就没有必要使用RepeatableSpec。</li>
<li>animation：将被重复的AnimationSpec，必须是DurationBasedAnimationSpec，也就是可以使用KeyframesSpec 、SnapSpec 和TweenSpec。</li>
<li>repeatMode：重复模式</li>
<li>initialStartOffset：动画开始的偏移</li>
</ul>
<p>RepeatMode有两种模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum class RepeatMode &#123;</span><br><span class="line">    //将重新启动动画，并从开始值到结束值进行动画处理。</span><br><span class="line">    Restart,</span><br><span class="line"></span><br><span class="line">    //将在动画重复时反转上一次迭代</span><br><span class="line">    Reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 RepeatMode.Reverse 模式下重复时，强烈建议迭代次数为奇数。否则，动画可能会在完成最后一次迭代时跳转到结束值。</p>
<p>initialStartOffset 可用于延迟动画的开始或将动画快进到给定的播放时间。 此起始偏移量不会重复，而动画中的延迟（如果有）将重复。 默认情况下，偏移量为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.jvm.JvmInline</span><br><span class="line">value class StartOffset private constructor(internal val value: Long) &#123;</span><br><span class="line">   </span><br><span class="line">    constructor(offsetMillis: Int, offsetType: StartOffsetType = StartOffsetType.Delay) : this(</span><br><span class="line">        (offsetMillis * offsetType.value).toLong()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val offsetMillis: Int</span><br><span class="line">        get() = abs(this.value.toInt())</span><br><span class="line"></span><br><span class="line">    val offsetType: StartOffsetType</span><br><span class="line">        get() = when (this.value &gt; 0) &#123;</span><br><span class="line">            true -&gt; StartOffsetType.FastForward</span><br><span class="line">            false -&gt; StartOffsetType.Delay</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StartOffset存储一个offsetMillis时间和StartOffsetType类型，StartOffsetType类型有两类：StartOffsetType.Delay延迟动画的开始和StartOffsetType.FastForward快进动画到给定的播放时间，并立即开始播放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.jvm.JvmInline</span><br><span class="line">value class StartOffsetType private constructor(internal val value: Int) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        //延迟动画的开始</span><br><span class="line">        val Delay = StartOffsetType(-1)</span><br><span class="line"></span><br><span class="line">        //快进动画到给定的播放时间，并立即开始播放。</span><br><span class="line">        val FastForward = StartOffsetType(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用repeatable，将animation设置为一个1秒的匀速变化的tween动画，重复3次，重复方式为反转重复，initialStartOffset设置为延迟500毫秒，StartOffsetType.FastForward。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun RepeatableDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = repeatable(</span><br><span class="line">            iterations = 3,</span><br><span class="line">            animation = tween(durationMillis = 1000, easing = LinearEasing),</span><br><span class="line">            repeatMode = RepeatMode.Reverse,</span><br><span class="line">            initialStartOffset = StartOffset(500, StartOffsetType.FastForward)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-repeatable&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个动画效果：快进到500毫秒处，然后立即开始匀速动画，又500毫秒后开始反转动画。</p>
<h2 id="InfiniteRepeatableSpec"><a href="#InfiniteRepeatableSpec" class="headerlink" title="InfiniteRepeatableSpec"></a>InfiniteRepeatableSpec</h2><p>InfiniteRepeatableSpec，构建一个基于DurationBasedAnimationSpec的无限重复动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">fun &lt;T&gt; infiniteRepeatable(</span><br><span class="line">    animation: DurationBasedAnimationSpec&lt;T&gt;,</span><br><span class="line">    repeatMode: RepeatMode = RepeatMode.Restart,</span><br><span class="line">    initialStartOffset: StartOffset = StartOffset(0)</span><br><span class="line">): InfiniteRepeatableSpec&lt;T&gt; =</span><br><span class="line">    InfiniteRepeatableSpec(animation, repeatMode, initialStartOffset)</span><br></pre></td></tr></table></figure>
<p>官方提供了infiniteRepeatable()方法用于构造InfiniteRepeatableSpec，相比RepeatableSpec少了一个参数iterations，无限重复动画自然是不需要重复次数的，其余参数都一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun InfiniteRepeatableDemo() &#123;</span><br><span class="line">    var small by remember &#123;</span><br><span class="line">        mutableStateOf(true)</span><br><span class="line">    &#125;</span><br><span class="line">    val size: Dp by animateDpAsState(</span><br><span class="line">        targetValue = if (small) 40.dp else 100.dp,</span><br><span class="line">        animationSpec = infiniteRepeatable(</span><br><span class="line">            animation = tween(durationMillis = 1000, easing = LinearEasing),</span><br><span class="line">            repeatMode = RepeatMode.Reverse,</span><br><span class="line">            initialStartOffset = StartOffset(500, StartOffsetType.FastForward)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Button(onClick = &#123; small = !small &#125;) &#123;</span><br><span class="line">            Text(text = &quot;改变方块大小-infiniteRepeatable&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(size)</span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FloatAnimationSpec"><a href="#FloatAnimationSpec" class="headerlink" title="FloatAnimationSpec"></a>FloatAnimationSpec</h2><p>FloatAnimationSpec是一个接口，有两个实现类，FloatTweenSpec仅针对Float类型做TweenSpec动画，FloatSpringSpec仅针对Float类型做SpringSpec动画。官方没有提供可以直接进行使用的方法，因为tween()和spring()支持全量数据类型，FloatAnimationSpec是底层做更精细的计算的时候才会去使用。</p>
<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>