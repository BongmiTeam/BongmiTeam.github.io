<!DOCTYPE html><html lang="en"><head><title>ART和JVM的区别</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>ART和JVM的区别</h1><div class="time">2022-11-01 by zhangyong</div><h2 id="ART基于寄存器，JVM基于栈"><a href="#ART基于寄存器，JVM基于栈" class="headerlink" title="ART基于寄存器，JVM基于栈"></a>ART基于寄存器，JVM基于栈</h2><p><img src="/images/17942410-af93837f33467394.webp"></p>
<p>堆区： 只存放类对象，实例化的数据放在堆区；堆区的数据放在主内存<br>方法区：又叫静态存储区，存放class文件和静态数据，全局变量;方法区的数据在主内存<br>栈区：存放方法局部变量，方法，线程不共享; 栈区的数据在高速缓冲区  </p>
<h3 id="主内存-高速缓冲区"><a href="#主内存-高速缓冲区" class="headerlink" title="主内存 高速缓冲区"></a>主内存 高速缓冲区</h3><p><img src="/images/17942410-d399ec19059fb3ed.webp"></p>
<p>堆区和方法区在内存条上<br>栈区在cpu的高速缓冲区上<br>因为cpu的读取速度在2.4G左右，内存条的速度1333M、1666M，两者之间有差异所以需要一个高速缓冲区（三级缓存）<br><img src="/images/20221101-160505.png"></p>
<h3 id="ART基于寄存器"><a href="#ART基于寄存器" class="headerlink" title="ART基于寄存器"></a>ART基于寄存器</h3><pre><code>public  Singleton getInstance() &#123;
    Singleton instance = new Singleton();
    return instance;
&#125;
</code></pre>
<p>翻译成arm指令</p>
<pre><code>0000: new-instance v0, Singleton // type@0000
0002: invoke-direct &#123;v0&#125;, Singleton.&lt;init&gt;:()V // method@0000
0005: return-object v0
</code></pre>
<h3 id="JVM基于栈"><a href="#JVM基于栈" class="headerlink" title="JVM基于栈"></a>JVM基于栈</h3><p>IDEA字节码<br><img src="/images/20221101-160830.png"></p>
<p>栈结构<br><img src="/images/407483503-61b2ca47c0c01_fix732.png"></p>
<h2 id="ART执行效率高"><a href="#ART执行效率高" class="headerlink" title="ART执行效率高"></a>ART执行效率高</h2><h3 id="更快的本机方法"><a href="#更快的本机方法" class="headerlink" title="更快的本机方法"></a>更快的本机方法</h3><p>使用 <strong>@FastNative</strong> 和 <strong>@CriticalNative</strong> 注解可以更快地调用Java Native Interface (JNI)。这些内置的 ART 运行时优化可加快 JNI 转换并替换现在已弃用的!bang JNI表示法。注释对非本机方法没有影响，并且仅可用于引导类bootclasspath上的平台 Java 语言代码（无 Play 商店更新）。</p>
<p>@FastNative注解支持非静态方法。如果方法将jobject作为参数或返回值访问，请使用此选项。</p>
<p>@CriticalNative注解提供了一种更快的方式来运行本机方法，但有以下限制：  </p>
<pre><code>方法必须是静态的——没有参数、返回值或隐式this的对象。
只有原始类型被传递给本机方法。
本机方法在其函数定义中不使用JNIEnv和jclass参数。
该方法必须使用RegisterNatives ，而不是依赖动态 JNI 链接。
@FastNative和@CriticalNative注释在执行本机方法时禁用垃圾收集。不要与长时间运行的方法一起使用，包括通常快速但通常不受限制的方法。
</code></pre>
<p>垃圾收集暂停可能会导致死锁。如果锁定尚未在本地释放（即在返回托管代码之前），则不要在快速本机调用期间获取锁定。这不适用于常规 JNI 调用，因为 ART 将执行的本机代码视为已挂起。</p>
<p>@FastNative可以将本机方法性能提高多达 3 倍， @CriticalNative CriticalNative 可以提高多达 5 倍。</p>
<pre><code>class ArtMethod   &#123;
    // The hotness we measure for this method. Managed by the interpreter. Not atomic, as we allow
    // 通过注释可以知道  该变量时标记经过 java方法运行的频率，
    uint16_t hotness_count_;

    struct PtrSizedFields &#123;
    // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.
    //通过google给我们的注释 可以知道，缓存一个方法对应的arm指令，快速的得到结果
    ArtMethod** dex_cache_resolved_methods_;
    //上面方法执行的结果 数据缓存在data_ 变量中，下次执行经过@FastNative修饰的java方法时，直接取出数据
    void* data_;
    //arm指令在内存中的地址，快速的定位到arm指令
    void* entry_point_from_quick_compiled_code_;
&#125; ptr_sized_fields_;  
</code></pre>
<h3 id="dex优化"><a href="#dex优化" class="headerlink" title="dex优化"></a>dex优化</h3><p>dex文件结构<br><img src="/images/out4fhht2b.png"></p>
<h4 id="odex"><a href="#odex" class="headerlink" title="odex"></a>odex</h4><p>因为 apk 实际为 zip 压缩包，虚拟机每次加载都需要从 apk 中读取classes.dex 文件，这样会耗费很多的时间，而如果采用了 odex 方式优化的 dex 文件，他包含了加载 dex 必须的依赖库文件列表，只需要直接加载而不需要再去解析。</p>
<p>在 Android N 之前，对于在 dalvik 环境中 使用 dexopt 来对 dex 字节码进行优化生成 odex 文件最终存在手机的 data/dalvik-cache 目录下，最后把 apk 文件中的 dex 文件删除。</p>
<p>在 Android O 之后，odex 是从 vdex 这个文件中 提取了部分模块生成的一个新的可执行二进制码文件 ， odex 从 vdex 中提取后，vdex 的大小就减少了。</p>
<p>第一次开机就会生成在 /system/app/&lt;packagename&gt;/oat/ 下<br>在系统运行过程中，虚拟机将其 从 /system/app 下 copy 到 /data/davilk-cache/ 下;<br>odex + vdex = apk 的全部源码 （vdex 并不是独立于 odex 的文件 odex + vdex 才代表一个 apk </p>
<h4 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h4><p>ART 推出了预先 (AOT) 编译，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。该实用工具接受 DEX 文件作为输入，并针对目标设备生成已编译应用的可执行文件。之后打开 App 的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。</p>
<p>AOT 是 art 的核心，oat 文件包含 oatdata 和 oatexec。前者包含 dex 文件内容，后者包含生成的本地机器指令，从这里看出 oat 文件回会比 dex 文件占用更大的存储空间。</p>
<p>因为 oat 文件包含生成的本地机器指令进而可以直接运行，它同样保存在手机的 data/dalvik-cache 目录下 PMS(PackgetManagerService)—&gt;installd(守护进程)——&gt;dex2oat(/system/bin/dex2oat) 。注意存放在 data/dalvik-cache 目录下的后缀名都仍为 .dex 前者其实表示一个优化过的 .dex 文件 后者为 .art 文件。</p>
<p>push 一个新的 apk 文件覆盖之前 /system/app 下 apk 文件，会触发 PKMS 扫描时下发 force_dex flag ，强行生成新的 vdex文件 ，覆盖之前的vdex 文件，由于某种机制，这个新 vdex 文件会 copy 到 /data/dalvik-cache/ 下，于是 art 文件也变化了。</p>
<h2 id="引用文档"><a href="#引用文档" class="headerlink" title="引用文档"></a>引用文档</h2><p>Android系统8.0为什么比7.0要快50%，深入虚拟机源码发现答案 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41373fc26fd1">https://www.jianshu.com/p/41373fc26fd1</a><br>art改进 <a target="_blank" rel="noopener" href="https://source.android.com/docs/core/runtime/improvements?hl=zh-cn">https://source.android.com/docs/core/runtime/improvements?hl=zh-cn</a><br>从JVM到Dalivk再到ART <a target="_blank" rel="noopener" href="https://blog.csdn.net/stven_king/article/details/102620708">https://blog.csdn.net/stven_king/article/details/102620708</a></p>
<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>