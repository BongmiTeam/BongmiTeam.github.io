<!DOCTYPE html><html lang="en"><head><title>Jetpack Compose State理解</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>Jetpack Compose State理解</h1><div class="time">2022-11-03 by liujian</div><p>Jetpack Compose 是推荐用于构建原生 Android 界面的新工具包。后续简称Jetpack Compose为Compose。</p>
<p>在了解State之前需要先对Compose及申明性编程式有个大概的了解，推荐看下文章<a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1350226238611550209"># 声明式 UI？Android 官方怒推的 Compose 到底是什么#</a></p>
<h4 id="State初体验"><a href="#State初体验" class="headerlink" title="State初体验"></a>State初体验</h4><p>好了，在你有一定了解的基础上，我们先来运行几个Demo，初步了解为何使用state。这个例子主要是想通过点击按钮，改变文案的显示。（这个过程称之为重组）</p>
<p>Demo1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class StateDemoActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        supportActionBar?.hide()</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, false)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            TestComposeTheme &#123;</span><br><span class="line">                var state = false</span><br><span class="line">                Log.e(&quot;StateDemoActivity&quot;, &quot;hashcode:$&#123;state.hashCode()&#125; value:$&#123;state&#125;&quot;)</span><br><span class="line">                Column(modifier = Modifier.fillMaxSize().systemBarsPadding()) &#123;</span><br><span class="line">                    Button(onClick = &#123;</span><br><span class="line">                        state = !state</span><br><span class="line">                        Log.e(&quot;StateDemoActivity&quot;, &quot;onClick hashcode:$&#123;state.hashCode()&#125; value:$&#123;state&#125;&quot;)</span><br><span class="line">                    &#125;, modifier = Modifier.fillMaxWidth()) &#123;</span><br><span class="line">                        Text(</span><br><span class="line">                            text = &quot;Change State:$&#123;state&#125;&quot;,</span><br><span class="line">                            color = MyColorTheme.textMain,</span><br><span class="line">                            fontSize = 20.sp</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StateDemoActivity        E  hashcode:1237 value:false</span><br><span class="line">StateDemoActivity        E  onClick hashcode:1231 value:true</span><br><span class="line">StateDemoActivity        E  onClick hashcode:1237 value:false</span><br><span class="line">StateDemoActivity        E  onClick hashcode:1231 value:true</span><br><span class="line">StateDemoActivity        E  onClick hashcode:1237 value:false</span><br></pre></td></tr></table></figure>
<p>可以发现，点击按钮Text显示的文本没有改变，没有达到预想的目的。</p>
<p>Demo2：这次我们使用官方的MutableState</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TestComposeTheme &#123;</span><br><span class="line">    var state = mutableStateOf(false)</span><br><span class="line">    Log.e(&quot;StateDemoActivity&quot;, &quot;hashcode:$&#123;state.hashCode()&#125; value:$&#123;state.value&#125;&quot;)</span><br><span class="line">    Column(modifier = Modifier.fillMaxSize().systemBarsPadding()) &#123;</span><br><span class="line">        Button(onClick = &#123;</span><br><span class="line">            state.value = !state.value</span><br><span class="line">            Log.e(&quot;StateDemoActivity&quot;, &quot;onClick hashcode:$&#123;state.hashCode()&#125; value:$&#123;state.value&#125;&quot;)</span><br><span class="line">        &#125;, modifier = Modifier.fillMaxWidth()) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = &quot;Change State:$&#123;state.value&#125;&quot;,</span><br><span class="line">                color = MyColorTheme.textMain,</span><br><span class="line">                fontSize = 20.sp</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下，显示的文案依然没有改变，但相比之前多了Column之前的打印，这表明方法体被重新执行了，state变量的哈希值也在变化。以上表现和普通java方法别无区别，state是方法中的局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StateDemoActivity        E  hashcode:103910553 value:false</span><br><span class="line">StateDemoActivity        E  onClick hashcode:103910553 value:true</span><br><span class="line">StateDemoActivity        E  hashcode:118168247 value:false</span><br><span class="line">StateDemoActivity        E  onClick hashcode:118168247 value:true</span><br><span class="line">StateDemoActivity        E  hashcode:245965755 value:false</span><br></pre></td></tr></table></figure>

<p>Demo3：这次我们稍作改动，额外使用remember函数，其他不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var state = remember &#123;</span><br><span class="line">    mutableStateOf(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下，按钮文字终于如预想的那样发生了变化，此外有个特别的现象是state变量的哈希值并没有发生变化，表明方法每次执行时，state变量并没有重新创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StateDemoActivity        E  hashcode:103910553 value:false</span><br><span class="line">StateDemoActivity        E  onClick hashcode:103910553 value:true</span><br><span class="line">StateDemoActivity        E  hashcode:103910553 value:true</span><br><span class="line">StateDemoActivity        E  onClick hashcode:103910553 value:false</span><br><span class="line">StateDemoActivity        E  hashcode:103910553 value:false</span><br></pre></td></tr></table></figure>
<p>remember方法内部必然有全局容器存储变量，源码中可以很明显的看出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">inline fun &lt;T&gt; remember(crossinline calculation: @DisallowComposableCalls () -&gt; T): T =</span><br><span class="line">    currentComposer.cache(false, calculation)</span><br></pre></td></tr></table></figure>

<p>综上我们可以知道，Compose是依赖对State变化的观察来重新执行Compose方法（准确来说Compose基于参数的比较结果来决定是否重组）</p>
<h4 id="重组与稳定类型"><a href="#重组与稳定类型" class="headerlink" title="重组与稳定类型"></a>重组与稳定类型</h4><p>接上文一个 Composable 函数在重组中被调用时，如果参数与上次调用时相比没有发生变化，则函数的执行会跳过重组，提升重组性能。需要特别说明<code>Compose不会因为被观察的对象与上次是同一个就跳过重组</code>。详情参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/vitaviva/article/details/126025275">Compose类型稳定性注解：@Stable &amp; @Immutable</a></p>
<h4 id="Composable的重组范围"><a href="#Composable的重组范围" class="headerlink" title="Composable的重组范围"></a>Composable的重组范围</h4><p>在之前的内容中，我们已经知道了参数的变化会影响重组是否执行，这就带了重组范围的问题。这方面大佬已经有了很好的文章。建议小伙伴先阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/vitaviva/article/details/115605867"># Jetpack Compose：理解composable的重组范围</a></p>
<p>当我阅读后用代码验证时却发现了异常，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class StateDemoActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private val TAG = StateDemoActivity::class.java.simpleName</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        supportActionBar?.hide()</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, false)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            TestComposeTheme &#123;</span><br><span class="line">                Log.e(TAG, &quot;Scope-1 run &quot;)</span><br><span class="line">                var counter by remember &#123;</span><br><span class="line">                    mutableStateOf(0)</span><br><span class="line">                &#125;</span><br><span class="line">                Column(modifier = Modifier.fillMaxSize().systemBarsPadding()) &#123; </span><br><span class="line">                    Log.e(TAG, &quot;Scope-2 run &quot;)</span><br><span class="line">                    Button(onClick = run &#123;</span><br><span class="line">                        Log.e(TAG, &quot;Button-onClick&quot;)</span><br><span class="line">                        return@run &#123; counter++ &#125;</span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;Scope-3 run &quot;)</span><br><span class="line">                        Text(text = &quot;+&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    Text(</span><br><span class="line">                        text = &quot;Counter:$&#123;counter&#125;&quot;,</span><br><span class="line">                        color = MyColorTheme.textMain,</span><br><span class="line">                        fontSize = 20.sp</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StateDemoActivity        E  Scope-1 run </span><br><span class="line">StateDemoActivity        E  Scope-2 run </span><br><span class="line">StateDemoActivity        E  Button-onClick</span><br><span class="line">StateDemoActivity        E  Scope-3 run </span><br></pre></td></tr></table></figure>
<p>按照文章内的说法<code>Scope-3 run </code>这行是不应该被打印出来的，即不应该参与重组的，可实际结果却相反。小伙伴可以自己思考下，稍后再往下翻看原因；</p>
<p>————–完美的分割线^_^————</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class StateDemoActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val TAG = StateDemoActivity::class.java.simpleName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StateDemoActivity        E  Scope-1 run </span><br><span class="line">StateDemoActivity        E  Scope-2 run </span><br><span class="line">StateDemoActivity        E  Button-onClick</span><br></pre></td></tr></table></figure>
<p>日志终于和理解的一样了，现在我们回头找原因，知道问题就出在打印的变量“TAG”身上。方法中各作用域Scope都读取了变量“TAG”，在第一个代码中该变量是个非稳定类型，故按钮触发重组时，为了保证正确性，所有引用到该变量的Scope都会重组；而第二个代码中“TAG”已经是个静态变量了，故而是个稳定类型，所以重组时不会引发非必要的重组。</p>
<h5 id="最后补充一点："><a href="#最后补充一点：" class="headerlink" title="最后补充一点："></a>最后补充一点：</h5><p>从Android View转Compose过程中，对LiveData的使用场景需要特别留意。因为原本对LiveData的观察是通过observe方法进行的，每次LiveData内容更新（即使值一样）回调依然会收到；转换为State之后，只有value变化了，才会引发重组；例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val missOut = MutableLiveData(false)</span><br><span class="line">...</span><br><span class="line">val state = viewModel.missOut.observeAsState(false).value</span><br></pre></td></tr></table></figure>
<p>多次调用<code>missOut.value = true</code>,state只有在第一次设置为true时引发重组。如果希望行为和之前observe一样，应该如下调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LaunchedEffect(key1 = Unit) &#123;</span><br><span class="line">    viewModel.missOut.asFlow().collect &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于compose为何能够观察到状态的变化，请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/vitaviva/article/details/124657607">带你了解 Jetpack Compose 快照系统</a></p>
<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>