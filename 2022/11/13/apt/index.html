<!DOCTYPE html><html lang="en"><head><title>apt</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>apt</h1><div class="time">2022-11-13 by xuhuanli</div><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><p>运行时注解是在程序运行时通过反射获取注解然后处理的，编译时注解是程序在编译期间通过注解处理器处理的</p>
<h4 id="APT技术的作用"><a href="#APT技术的作用" class="headerlink" title="APT技术的作用"></a>APT技术的作用</h4><p>用来生成模版代码</p>
<h3 id="APT的两个要素"><a href="#APT的两个要素" class="headerlink" title="APT的两个要素"></a>APT的两个要素</h3><ol>
<li>注解</li>
<li>注解处理器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kapt &quot;com.google.dagger:hilt-compiler:2.44&quot;</span><br><span class="line">annotationProcessor &quot;com.google.dagger:hilt-compiler:2.44&quot;</span><br></pre></td></tr></table></figure>
<p>kapt/annotationProcessor关键字依赖了一个库，javac在<u>编译的过程中</u>就会去这个库中找符合注解处理器规则的类。 找到这个类后就把这个类认为是一个注解处理器。 但是一个大型项目中 往往会存在许多个apt库 那么这么多个处理器它是怎么被加载出来的</p>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><blockquote>
<p>Java SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制.</p>
<p>1.定义一个接口文件<br>2.写出多个该接口文件的实现<br>3.在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件 , 内容是要接口的实现类全路径<br>4.使用ServiceLoader类 来获取到这些实现的接口</p>
</blockquote>
<p>写法有点像什么 aidl<br>相比AIDL的方式，缺点是不支持跨进程，需要在接口实现的地方自己处理。</p>
<h4 id="AutoService"><a href="#AutoService" class="headerlink" title="AutoService"></a>AutoService</h4><p>他可以帮我们在编译的时候动态去生成这些东西<br>通过<code>@AutoService</code>省下最麻烦的第3步</p>
<h4 id="javac是如何调用注解处理器的"><a href="#javac是如何调用注解处理器的" class="headerlink" title="javac是如何调用注解处理器的"></a>javac是如何调用注解处理器的</h4><p>javac源码 idea中打开</p>
<ol>
<li>com.sun.tools.javac.Main</li>
<li>调用compile方法 返回Result枚举类 注意processors参数null</li>
<li>最后走到五个参数的compile方法 找到 <code>comp = JavaCompiler.instance(context);</code>和<code>comp.compile(fileObjects, classnames.toList(), processors);</code></li>
<li>进到JavaCompiler类中的compile方法里面 找到<code>initProcessAnnotations(processors);</code></li>
<li>在initProcessAnnotations方法中找到<code>procEnvImpl.setProcessors(processors);</code>然后进入<code>initProcessorIterator</code></li>
<li>最后找到<code>new ServiceIterator(processorClassLoader, log);</code><br>由于processorNames == null，进到else<br>然后看到<code>ServiceLoader.load(Processor.class, classLoader);</code><br>上面6步就是processor的加载</li>
<li>加载完成后返回 继续执行 <code>discoveredProcs = new DiscoveredProcessors(processorIterator);</code> 然后在JavaCompiler类中继续执行 找到<code>procEnvImpl.doProcessing</code></li>
<li>找到<code>round.run(false, false);</code>观察注释 明确这里执行processors 内部执行<code>discoverAndRunProcs</code></li>
<li>找到<code>callProcessor(ps.processor, typeElements, renv);</code>这个方法内调用了process方法 传入了Set&lt;? extends TypeElement&gt; tes,和RoundEnvironment<br>上面3步就是process方法的执行</li>
<li>观察do-while的条件 moreToDo表示是否有新的文件生成 errorStatus表示错误状态 第一次执行的是否moreToDO为true 如果不出错 errorStatus为false 满足while条件 继续执行 第二次</li>
<li>第二次的时候没有新的文件生成 跳出while</li>
<li>跳出while后继续执行 有看到一行代码<br><code>round.run(true, errorStatus);</code>和注释<code>// run last round</code></li>
<li>所以apt里面process方法执行次数是2+N</li>
</ol>
<h3 id="核心process方法"><a href="#核心process方法" class="headerlink" title="核心process方法"></a>核心process方法</h3><ul>
<li>RoundEnvironment<br>容器 装了所有我们声明这个注解处理器能处理的注解的内容(类、方法、成员变量)<br>在用反射的时候 我们用Class Method Field来表示类方法和成员变量<br>在注解处理器中也有一个类似的东西 Element<br>如<img src="/images/apt_01.png" width="716" height="440" /></li>
</ul>
<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>