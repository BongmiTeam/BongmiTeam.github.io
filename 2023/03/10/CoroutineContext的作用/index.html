<!DOCTYPE html><html lang="en"><head><title>CoroutineContext的作用</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>CoroutineContext的作用</h1><div class="time">2023-03-10 by liujian</div><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>先说总结，CoroutineContext的作用是为协程存储各种类信息，本质上是一种集合(可以理解为一种Map)；存储的这些类都是CoroutineContext的具体子类，他们都有各自的作用，在使用时直接通过CoroutineContext的get方法取出，非常方便；</p>
<p>CoroutineContext的源码在CoroutineContext.kt文件中，代码很短，但是细节需要特别注意。先看类说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Persistent context for the coroutine. It is an indexed set of Element instances. An indexed set is a mix between a set and a map. Every element in this set has a unique Key.</span><br></pre></td></tr></table></figure>
<p>翻译下：<br><code>为协程提供上下文。它是Element实例的索引集。索引集是集和映射之间的混合体。这个集合中的每个元素都有一个唯一的Key。</code></p>
<p>在此建议大家先阅读CoroutineContext源码，再看下文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qfanmingyiq/article/details/105081080">Kotlin协程源码分析-7 Context左向链表 </a>；</p>
<p>先将文章中的示例代码拿出来，方便大家后续查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class My3CoroutineName(</span><br><span class="line">    val name: String</span><br><span class="line">) : AbstractCoroutineContextElement(My3CoroutineName) &#123;</span><br><span class="line">    public companion object Key : CoroutineContext.Key&lt;My3CoroutineName&gt;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String = &quot;CoroutineName($name)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class My4CoroutineName(</span><br><span class="line">    val name: String</span><br><span class="line">) : AbstractCoroutineContextElement(My4CoroutineName) &#123;</span><br><span class="line"></span><br><span class="line">    public companion object Key : CoroutineContext.Key&lt;My4CoroutineName&gt;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String = &quot;CoroutineName($name)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有一个特别需要说明的点就是<code>My3CoroutineName</code>继承了类<code>AbstractCoroutineContextElement</code>，该类定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCoroutineContextElement(public override val key: Key&lt;*&gt;) : Element</span><br></pre></td></tr></table></figure>
<p>构造函数传递的参数类型是<code>key</code>类型，而我们传递的是<code>My3CoroutineName</code>，貌似错误但却能正常运行，因为这里用到了Kotlin的语法糖；此处的<code>My3CoroutineName</code>实际指向的是该类的伴生对象<code>Key</code>；这个用法在协程中使用广泛。</p>
<ul>
<li><p>CoroutineScope.launch创建newContext时，<code>combined[ContinuationInterceptor]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext &#123;</span><br><span class="line">    val combined = foldCopies(coroutineContext, context, true)</span><br><span class="line">    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined</span><br><span class="line">    return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null)</span><br><span class="line">        debug + Dispatchers.Default else debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractCoroutine初始化时获取父Job时，<code>parentContext[Job]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">    if (initParentJob) initParentJob(parentContext[Job])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h2><p>文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfanmingyiq/article/details/105081080">Kotlin协程源码分析-7 Context左向链表 </a>中的给出的示例对于大家理解左向链表有着非常大的帮助，在此额外补充个示例，小伙伴可以自己先思考下，再比对下结果是否与自己想的一致；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun studyContext4() &#123;</span><br><span class="line">    val my3CoroutineName = My3CoroutineName(&quot;item3&quot;)</span><br><span class="line">    val my4CoroutineName = My4CoroutineName(&quot;item4&quot;)</span><br><span class="line">    val my5CoroutineName = My3CoroutineName(&quot;item5&quot;)</span><br><span class="line"></span><br><span class="line">    val newElement = (my3CoroutineName + my4CoroutineName) + my5CoroutineName</span><br><span class="line"></span><br><span class="line">    println(&quot;(3+4)+5:$newElement&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(3+4)+5:[CoroutineName(item4), CoroutineName(item5)]</span><br></pre></td></tr></table></figure>
<p>我们发现<code>item3</code>被移除掉了，本质原因在文章开头说过了，<code>这个集合中的每个元素都有一个唯一的Key</code>，<code>item3</code>，<code>item5</code>虽然是2个对象，但是他们具有相同的Key，所以在执行plus操作时，原先的<code>item3</code>会被移除掉,结果就是<code>item4</code>，<code>item5</code>。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>使用一个实际工作的例子来结束这篇文章。如果之前没有用过异常处理器的小伙伴，建议阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_14876133/article/details/124009779">Kotlin 协程的异常处理</a>， <a target="_blank" rel="noopener" href="https://fanmingyi.blog.csdn.net/article/details/105733824">Kotlin协程核心库分析-5 Job异常处理器注意点</a></p>
<p>实际开发工作中，我们有时需要对协程可能出现的异常增加try catch处理逻辑，但是每次编写这样的样板代码，浪费时间且毫无营养，于是就想着做个包装方法处理这段逻辑；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; CoroutineScope.launchWithCatch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    onComplete: ((Result&lt;T&gt;) -&gt; Unit)? = null,</span><br><span class="line">    onCancel: (() -&gt; Unit)? = null,</span><br><span class="line">    errorHandler: ((exception: Throwable) -&gt; Unit)? = null,</span><br><span class="line">    onFinally:((Result&lt;T&gt;) -&gt; Unit)? = null,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; T</span><br><span class="line">): Job &#123;</span><br><span class="line">    val ref = AtomicReference&lt;CoroutineContext&gt;(null)</span><br><span class="line">    //由于当前的CoroutineScope不一定是根协程；因此必须加入SupervisorJob；否则可能出现CoroutineExceptionHandler无法捕获的bug请注意</span><br><span class="line">    return this.launch(context + SupervisorJob() + CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        //只有当coroutineContext是根coroutineContext时才表明是一个未处理的子协程异常，</span><br><span class="line">        //否则可能是supervisorScope未配置CoroutineExceptionHandler导致的异常传递，此时根协程会进行执行coroutineContext:$coroutineContext ref.get():$&#123;ref.get()&#125;&quot;, )</span><br><span class="line">        throwable.printStackTrace()</span><br><span class="line">        if (coroutineContext == ref.get()) &#123;</span><br><span class="line">            handleException(throwable, errorHandler, onComplete, onFinally)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        ref.set(this.coroutineContext)</span><br><span class="line">        try &#123;</span><br><span class="line">            val result = block()</span><br><span class="line">            onComplete?.invoke(Result.success(result))</span><br><span class="line">            onFinally?.invoke(Result.success(result))</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            if (e is CancellationException) &#123;</span><br><span class="line">                onCancel?.invoke()</span><br><span class="line">                onFinally?.invoke(Result.failure(e))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun &lt;T&gt; handleException(</span><br><span class="line">    e: Throwable,</span><br><span class="line">    errorHandler: ((exception: Throwable) -&gt; Unit)?,</span><br><span class="line">    onComplete: ((Result&lt;T&gt;) -&gt; Unit)? = null,</span><br><span class="line">    onFinally:((Result&lt;T&gt;) -&gt; Unit)? = null</span><br><span class="line">) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">    //异常处理</span><br><span class="line">    try &#123;</span><br><span class="line">        errorHandler?.invoke(e)</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        onComplete?.invoke(Result.failure(e))</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        onFinally?.invoke(Result.failure(e))</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码测试正常异常处理，但实际上这段代码存在逻辑隐患，读者朋友可以仔细思考下，问题出在哪里了；<br>下面给出异常case，在Android activity oncreate方法中执行以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private fun testLaunchWithCatch() &#123;</span><br><span class="line">    lifecycleScope.launchWithCatch &#123;</span><br><span class="line">        while (isActive) &#123;</span><br><span class="line">            // do loop operate</span><br><span class="line">            println(&quot;&gt;&gt;&gt;&gt;I&#x27;m do loop&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现即使activity退出了，协程依然在工作，<code>&gt;&gt;&gt;&gt;I&#39;m do loop</code>会始终输出;<br>问题原因就在于，<code>SupervisorJob()</code>的加入导致了原先的父子结构发生了变化；他的继承关系是<code>SupervisorJob</code>–〉<code>JobImpl</code>–〉<code>JobSupport</code>–〉<code>Job</code>；<br>回忆下文章开头协程获取设置父Job的场景，代码在类<code>AbstractCoroutine</code>的初始化函数中，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">    if (initParentJob) initParentJob(parentContext[Job])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用launchWithCatch导致新生成的协程不再是lifecycleScope的子协程,而是SupervisorJob的子协程，因此当activity页面lifecycleScope cancel时，刚刚发起的协程无法正常关闭；</p>
<p>好了，问题已经知道了，提供解决办法就是让SupervisorJob变成lifecycleScope的子协程即可，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; CoroutineScope.launchWithCatch(</span><br><span class="line">...</span><br><span class="line">val parentJob = context[Job] ?: coroutineContext[Job]</span><br><span class="line">return this.launch(context + SupervisorJob(parentJob) + CoroutineExceptionHandler &#123; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>