<!DOCTYPE html><html lang="en"><head><title>flutter布局方式解析</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><p><span></span><a href="/">返回</a><span></span></p><h1>flutter布局方式解析</h1><div class="time">2023-07-25 by 章勇</div><h2 id="四棵树"><a href="#四棵树" class="headerlink" title="四棵树"></a>四棵树</h2><p><img src="/images/v2-c7dad3c9a8967df441f12e7958eecb65_1440w.png" alt="Alt text">   </p>
<ul>
<li>Widget Tree用于整体的布局的配置</li>
<li>Element Tree负责Widget的生命周期，管理父子关系</li>
<li>RenderObject Tree负责确定大小并渲染  </li>
<li>根据RenderObject Tree生成 Layer 树，然后上屏显示  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class Widget extends DiagnosticableTree &#123;</span><br><span class="line">  /// Initializes [key] for subclasses.</span><br><span class="line">  const Widget(&#123; this.key &#125;);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  /// Inflates this configuration to a concrete instance.</span><br><span class="line">  ///</span><br><span class="line">  /// A given widget can be included in the tree zero or more times. In particular</span><br><span class="line">  /// a given widget can be placed in the tree multiple times. Each time a widget</span><br><span class="line">  /// is placed in the tree, it is inflated into an [Element], which means a</span><br><span class="line">  /// widget that is incorporated into the tree multiple times will be inflated</span><br><span class="line">  /// multiple times.</span><br><span class="line">  @protected</span><br><span class="line">  @factory</span><br><span class="line">  Element createElement();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Element由Widget创建，子类实现时每次都是new一个新对象返回，所以一个Widget可以在多个地方使用而不会有冲突。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/// RenderObjectWidgets provide the configuration for [RenderObjectElement]s,</span><br><span class="line">/// which wrap [RenderObject]s, which provide the actual rendering of the</span><br><span class="line">/// application.</span><br><span class="line">///</span><br><span class="line">/// See also:</span><br><span class="line">///</span><br><span class="line">///  * [MultiChildRenderObjectWidget], which configures a [RenderObject] with</span><br><span class="line">///    a single list of children.</span><br><span class="line">///  * [SlottedMultiChildRenderObjectWidgetMixin], which configures a</span><br><span class="line">///    [RenderObject] that organizes its children in different named slots.</span><br><span class="line">abstract class RenderObjectWidget extends Widget &#123;</span><br><span class="line">  /// Abstract const constructor. This constructor enables subclasses to provide</span><br><span class="line">  /// const constructors so that they can be used in const expressions.</span><br><span class="line">  const RenderObjectWidget(&#123; super.key &#125;);</span><br><span class="line"></span><br><span class="line">  /// RenderObjectWidgets always inflate to a [RenderObjectElement] subclass.</span><br><span class="line">  @override</span><br><span class="line">  @factory</span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  /// Creates an instance of the [RenderObject] class that this</span><br><span class="line">  /// [RenderObjectWidget] represents, using the configuration described by this</span><br><span class="line">  /// [RenderObjectWidget].</span><br><span class="line">  ///</span><br><span class="line">  /// This method should not do anything with the children of the render object.</span><br><span class="line">  /// That should instead be handled by the method that overrides</span><br><span class="line">  /// [RenderObjectElement.mount] in the object rendered by this object&#x27;s</span><br><span class="line">  /// [createElement] method. See, for example,</span><br><span class="line">  /// [SingleChildRenderObjectElement.mount].</span><br><span class="line">  @protected</span><br><span class="line">  @factory</span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  /// Copies the configuration described by this [RenderObjectWidget] to the</span><br><span class="line">  /// given [RenderObject], which will be of the same type as returned by this</span><br><span class="line">  /// object&#x27;s [createRenderObject].</span><br><span class="line">  ///</span><br><span class="line">  /// This method should not do anything to update the children of the render</span><br><span class="line">  /// object. That should instead be handled by the method that overrides</span><br><span class="line">  /// [RenderObjectElement.update] in the object rendered by this object&#x27;s</span><br><span class="line">  /// [createElement] method. See, for example,</span><br><span class="line">  /// [SingleChildRenderObjectElement.update].</span><br><span class="line">  @protected</span><br><span class="line">  void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  /// A render object previously associated with this widget has been removed</span><br><span class="line">  /// from the tree. The given [RenderObject] will be of the same type as</span><br><span class="line">  /// returned by this object&#x27;s [createRenderObject].</span><br><span class="line">  @protected</span><br><span class="line">  void didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderObject是RenderObjectWidget创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  @protected</span><br><span class="line">  ContainerLayer? get layer &#123;</span><br><span class="line">    assert(!isRepaintBoundary || _layerHandle.layer == null || _layerHandle.layer is OffsetLayer);</span><br><span class="line">    return _layerHandle.layer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @protected</span><br><span class="line">  set layer(ContainerLayer? newLayer) &#123;</span><br><span class="line">    assert(</span><br><span class="line">      !isRepaintBoundary,</span><br><span class="line">      &#x27;Attempted to set a layer to a repaint boundary render object.\n&#x27;</span><br><span class="line">      &#x27;The framework creates and assigns an OffsetLayer to a repaint &#x27;</span><br><span class="line">      &#x27;boundary automatically.&#x27;,</span><br><span class="line">    );</span><br><span class="line">    _layerHandle.layer = newLayer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final LayerHandle&lt;ContainerLayer&gt; _layerHandle = LayerHandle&lt;ContainerLayer&gt;();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  @protected</span><br><span class="line">  void performLayout();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="布局思想"><a href="#布局思想" class="headerlink" title="布局思想"></a>布局思想</h2><p>首先，上层 widget 向下层 widget 传递约束条件；<br>然后，下层 widget 向上层 widget 传递大小信息。<br>最后，上层 widget 决定下层 widget 的位置。</p>
<h2 id="严格约束（Tight）"><a href="#严格约束（Tight）" class="headerlink" title="严格约束（Tight）"></a>严格约束（Tight）</h2><p>指定大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BoxConstraints.tight(Size size)</span><br><span class="line">    : minWidth = size.width,</span><br><span class="line">      maxWidth = size.width,</span><br><span class="line">      minHeight = size.height,</span><br><span class="line">      maxHeight = size.height;</span><br></pre></td></tr></table></figure>

<h2 id="宽松约束（Loose）"><a href="#宽松约束（Loose）" class="headerlink" title="宽松约束（Loose）"></a>宽松约束（Loose）</h2><p>限制了最大，可以在宽高可以在[0, max]之间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BoxConstraints.loose(Size size)</span><br><span class="line">    : minWidth = 0.0,</span><br><span class="line">      maxWidth = size.width,</span><br><span class="line">      minHeight = 0.0,</span><br><span class="line">      maxHeight = size.height;</span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><a target="_blank" rel="noopener" href="https://flutter.cn/docs/ui/layout/constraints">https://flutter.cn/docs/ui/layout/constraints</a></p>
<p><img src="/images/screenshot-20230802-141851.png" alt="Alt text"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Expanded(</span><br><span class="line">    child: ConstrainedBox(</span><br><span class="line">        constraints: const BoxConstraints.tightFor(</span><br><span class="line">            width: double.infinity, height: double.infinity),</span><br><span class="line">        child: widget.examples[count - 1]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>ConstrainedBox对应的RenderObject是RenderConstrainedBox</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  @override</span><br><span class="line">  void performLayout() &#123;</span><br><span class="line">    final BoxConstraints constraints = this.constraints;</span><br><span class="line">    if (child != null) &#123;</span><br><span class="line">      child!.layout(_additionalConstraints.enforce(constraints), parentUsesSize: true);</span><br><span class="line">      size = child!.size;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      size = _additionalConstraints.enforce(constraints).constrain(Size.zero);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  BoxConstraints enforce(BoxConstraints constraints) &#123;</span><br><span class="line">    return BoxConstraints(</span><br><span class="line">      minWidth: clampDouble(minWidth, constraints.minWidth, constraints.maxWidth),</span><br><span class="line">      maxWidth: clampDouble(maxWidth, constraints.minWidth, constraints.maxWidth),</span><br><span class="line">      minHeight: clampDouble(minHeight, constraints.minHeight, constraints.maxHeight),</span><br><span class="line">      maxHeight: clampDouble(maxHeight, constraints.minHeight, constraints.maxHeight),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">double clampDouble(double x, double min, double max) &#123;</span><br><span class="line">  assert(min &lt;= max &amp;&amp; !max.isNaN &amp;&amp; !min.isNaN);</span><br><span class="line">  if (x &lt; min) &#123;</span><br><span class="line">    return min;</span><br><span class="line">  &#125;</span><br><span class="line">  if (x &gt; max) &#123;</span><br><span class="line">    return max;</span><br><span class="line">  &#125;</span><br><span class="line">  if (x.isNaN) &#123;</span><br><span class="line">    return max;</span><br><span class="line">  &#125;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明ConstrainedBox的大小不会超过父级给它的边界<br>那么父级给了它什么样的边界呢<br>this.constraints来自上一级Expanded</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Expanded extends Flexible &#123;</span><br><span class="line">  /// Creates a widget that expands a child of a [Row], [Column], or [Flex]</span><br><span class="line">  /// so that the child fills the available space along the flex widget&#x27;s</span><br><span class="line">  /// main axis.</span><br><span class="line">  const Expanded(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    super.flex,</span><br><span class="line">    required super.child,</span><br><span class="line">  &#125;) : super(fit: FlexFit.tight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候，RenderObject需要在其子节点中存储一些数据，比如用于布局的一些参数，或者和其他子节点之间的关系。为此，Flutter提供了ParentData，用于存储父节点的一些信息。每个RenderObject都有这个成员变量，该成员在setupParentData方法中初始化。子类如果需要ParentData的某个子类，需要重写该方法，并在该方法中对ParentData进行初始化。<br>Expanded不提供RenderObject，它通过为子节点添加ParentData，让Expanded的父节点知道ConstraintBox如何布局，这就是为什么RenderObject树的数量和Widget数不是一一对应的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">late final double minChildExtent;</span><br><span class="line">switch (_getFit(child)) &#123;</span><br><span class="line">  case FlexFit.tight:</span><br><span class="line">    assert(maxChildExtent &lt; double.infinity);</span><br><span class="line">    minChildExtent = maxChildExtent;</span><br><span class="line">  case FlexFit.loose:</span><br><span class="line">    minChildExtent = 0.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/screenshot-20230802-153249.png" alt="Alt text"><br>Center对应的performLayout  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void performLayout() &#123;</span><br><span class="line">  final BoxConstraints constraints = this.constraints;</span><br><span class="line">  final bool shrinkWrapWidth = _widthFactor != null || constraints.maxWidth == double.infinity;</span><br><span class="line">  final bool shrinkWrapHeight = _heightFactor != null || constraints.maxHeight == double.infinity;</span><br><span class="line"></span><br><span class="line">  if (child != null) &#123;</span><br><span class="line">    child!.layout(constraints.loosen(), parentUsesSize: true);</span><br><span class="line">    size = constraints.constrain(Size(</span><br><span class="line">      shrinkWrapWidth ? child!.size.width * (_widthFactor ?? 1.0) : double.infinity,</span><br><span class="line">      shrinkWrapHeight ? child!.size.height * (_heightFactor ?? 1.0) : double.infinity,</span><br><span class="line">    ));</span><br><span class="line">    alignChild();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    size = constraints.constrain(Size(</span><br><span class="line">      shrinkWrapWidth ? 0.0 : double.infinity,</span><br><span class="line">      shrinkWrapHeight ? 0.0 : double.infinity,</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便看下Center怎么定位子节点位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Offset alongOffset(Offset other) &#123;</span><br><span class="line">  final double centerX = other.dx / 2.0;</span><br><span class="line">  final double centerY = other.dy / 2.0;</span><br><span class="line">  return Offset(centerX + x * centerX, centerY + y * centerY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这个思路可以把后面所有的布局例子都看一遍</p>
<div>
    <section id="comments" class="comments">
        <style>
            .utterances{max-width: 100%;}
        </style>
        <script 
            src="https://utteranc.es/client.js"
            repo="BongmiTeam/BongmiTeam.github.io"
            issue-term="pathname"
            label="Comment"
            theme="boxy-light"
            crossorigin="anonymous"
            async>
        </script>
    </section>
</div>

</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>